---
title: "Research"
author:
  - name: Seungju Kim
    orcid: 0009-0009-5166-9170
    email: seungju7@illinois.edu
    affiliation: 
      - name: University of Illinois, Urbana-Champaign
        department: Psychology
title-block-banner: false
format: html
comments: false
description: "" 
listing:
  - id: published
    include: 
      type: "Published"
    contents: papers.yaml
    template: papers.ejs
    filter-ui: false
    sort: "date desc"
    sort-ui: false
    #categories: true  
  - id: preprints
    include: 
      type: "Preprint"    # Changed from lowercase "preprint" to "Preprint" to match YAML
    contents: papers.yaml
    template: papers.ejs
    #filter-ui: true
    sort: "date desc" 
    sort-ui: false
    #categories: true
toc: true    
#page-layout: full
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE
#| include: FALSE
# Required packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load(scholar, rcrossref, dplyr, stringr, htmltools, here, tidyverse, ggiraph, patchwork, gdtools, gfonts)

# Register a web font for better consistency
register_gfont("Inter")
```

<a href="https://docs.google.com/document/d/1bB2WnhJIigiq-S9CmZNKPpmEYytFz98U/export?format=pdf" 
   class="btn btn-success" 
   target="_blank"
   id="cv-download-button"
   data-tracking="cv-download">
    <i class="bi bi-file-earmark-pdf"></i> Download CV
</a>
<span id="count" class="badge bg-primary ms-2">0</span>


<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js';
  import { getFirestore, doc, getDoc, runTransaction } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js';

  document.addEventListener('DOMContentLoaded', function() {
    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "{{ FB_API }}",
      authDomain: "cv-download-40a41.firebaseapp.com",
      projectId: "cv-download-40a41",
      storageBucket: "cv-download-40a41.firebasestorage.app",
      messagingSenderId: "842134969852",
      appId: "{{ APPID }}",
      measurementId: "G-7149VRMDP5"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const countRef = doc(db, "counts", "cvDownload"); // Updated to match your new structure

    // Function to increment the CV download count
    async function incrementCount() {
      console.log("Increment button clicked");
      try {
        await runTransaction(db, async (transaction) => {
          const countDoc = await transaction.get(countRef);
          if (!countDoc.exists()) {
            console.log("Document does not exist. Creating new document.");
            transaction.set(countRef, { counts: 1 }); // Changed count to counts to match your field name
          } else {
            const newCount = countDoc.data().counts + 1; // Changed count to counts
            console.log("Document exists. Updating count to:", newCount);
            transaction.update(countRef, { counts: newCount }); // Changed count to counts
          }
        });
        console.log("Transaction successful!");
        getCount();
      } catch (error) {
        console.error("Transaction failed:", error);
      }
    }

    // Function to get the current CV download count
    async function getCount() {
      console.log("Fetching count from Firestore");
      try {
        const countDoc = await getDoc(countRef);
        if (countDoc.exists()) {
          console.log("Count document exists:", countDoc.data());
          document.getElementById("count").innerText = countDoc.data().counts; // Changed count to counts
        } else {
          console.log("Count document does not exist");
          document.getElementById("count").innerText = "0";
        }
      } catch (error) {
        console.error("Error getting document:", error);
      }
    }

    // Load the current count when the page loads
    getCount();

    // Attach event listener to the CV download button
    document.getElementById('cv-download-button').addEventListener('click', incrementCount);
  });
</script>

```{r}
#| echo: FALSE
#| warning: FALSE
#| asis: TRUE
pacman::p_load(httr, jsonlite, tidyverse, ggiraph, patchwork, here)

scholar_id <- "JWNJV9UAAAAJ"

# SerpApi functions
get_citation_history_serpapi <- function(scholar_id, api_key) {
  url <- "https://serpapi.com/search.json"
  
  response <- GET(url, query = list(
    engine = "google_scholar_author",
    author_id = scholar_id,
    api_key = api_key
  ))
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text"))
    
    # Extract citation graph data - it's already a data frame!
    if ("cited_by" %in% names(data) && "graph" %in% names(data$cited_by)) {
      citation_graph <- data$cited_by$graph
      
      # The graph has 'year' and 'citations' columns (not 'cited_by')
      citation_data <- data.frame(
        year = as.numeric(citation_graph$year),
        cites = as.numeric(citation_graph$citations)  # Fixed: was 'cited_by', now 'citations'
      )
      return(citation_data)
    }
  }
  return(NULL)
}

get_publications_serpapi <- function(scholar_id, api_key) {
  url <- "https://serpapi.com/search.json"
  
  # Get the publications list
  response <- GET(url, query = list(
    engine = "google_scholar_author",
    author_id = scholar_id,
    api_key = api_key,
    view_op = "list_works",
    num = 100
  ))
  
  if (status_code(response) == 200) {
    data <- fromJSON(content(response, "text"))
    
    if ("articles" %in% names(data)) {
      publications <- data$articles
      
      # Filter and count by year (no OSF filtering since no publication_info field)
      if (nrow(publications) > 0 && "year" %in% names(publications)) {
        publication_data <- publications %>%
          filter(!is.na(year)) %>%  # Remove rows with missing years
          # Note: Removed OSF filtering since publication_info field doesn't exist in this response
          count(year, name = "publications")  # Count publications per year
        
        return(publication_data)
      }
    }
  }
  return(NULL)
}

# Get API key from environment variable
api_key <- Sys.getenv("SERPAPI_KEY")

if (api_key == "") {
  stop("SERPAPI_KEY not found in environment variables. Please set your SerpApi key.")
}

# Get citation data from API
citation_data <- tryCatch({
  get_citation_history_serpapi(scholar_id, api_key)
}, error = function(e) {
  stop(paste("Error fetching citation data via SerpApi:", e$message))
})

if (is.null(citation_data)) {
  stop("No citation data returned from SerpApi")
}

# Get publication data from API
publication_data <- tryCatch({
  get_publications_serpapi(scholar_id, api_key)
}, error = function(e) {
  stop(paste("Error fetching publication data via SerpApi:", e$message))
})

if (is.null(publication_data)) {
  stop("No publication data returned from SerpApi")
}

# Calculate totals
total_citations <- sum(citation_data$cites)
total_publications <- sum(publication_data$publications)

# Create citations plot (horizontal)
citations_plot <- citation_data %>%
  ggplot(aes(x = cites, y = as.factor(year))) +
  geom_col_interactive(
    aes(tooltip = cites),
    fill = "#4A90A4",
    width = 0.7
  ) +
  labs(
    title = "Citation History Over Time",
    subtitle = paste("Total Citations:", total_citations),
    x = "# of Citations",
    y = "Year"
  ) +
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "#0E2638", color = NA),
    panel.background = element_rect(fill = "#0E2638", color = NA),
    plot.title = element_text(size = 14, face = "bold", color = "#EBEBEB", family = "Helvetica"),
    plot.subtitle = element_text(size = 12, color = "#EBEBEB", family = "Helvetica"),
    axis.title = element_text(size = 12, color = "#EBEBEB", family = "Helvetica"),
    axis.text = element_text(size = 10, color = "#EBEBEB", family = "Helvetica"),
    axis.line = element_line(color = "#EBEBEB", size = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Create publications plot (horizontal)
publications_plot <- publication_data %>%
  ggplot(aes(x = publications, y = as.factor(year))) +
  geom_col_interactive(
    aes(tooltip = publications),
    fill = "#7FB069",
    width = 0.7
  ) +
  labs(
    title = "Publications Over Time",
    subtitle = paste("Total Publications:", total_publications),
    x = "# of Publications",
    y = "Year"
  ) +
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "#0E2638", color = NA),
    panel.background = element_rect(fill = "#0E2638", color = NA),
    plot.title = element_text(size = 14, face = "bold", color = "#EBEBEB", family = "Helvetica"),
    plot.subtitle = element_text(size = 12, color = "#EBEBEB", family = "Helvetica"),
    axis.title = element_text(size = 12, color = "#EBEBEB", family = "Helvetica"),
    axis.text = element_text(size = 10, color = "#EBEBEB", family = "Helvetica"),
    axis.line = element_line(color = "#EBEBEB", size = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Combine plots side by side
combined_plot <- citations_plot + publications_plot + 
  plot_layout(ncol = 2) +
  plot_annotation(
    caption = paste("Data from Google Scholar via SerpApi (", Sys.Date(), ")", sep = ""),
    theme = theme(
      plot.background = element_rect(fill = "#0E2638", color = NA),
      plot.caption = element_text(size = 10, color = "#EBEBEB", family = "Helvetica")
    )
  )

# Create the girafe object with Helvetica font
interactive_plot <- girafe(
  ggobj = combined_plot,
  width_svg = 12,
  height_svg = 5,
  fonts = list(sans = "Helvetica")
)

interactive_plot
```

## Published Papers

:::{#published}
:::

## Preprints
:::callout-warning
A preprint is an early-stage research paper not yet peer-reviewed or published in a scientific journal. Findings should be considered preliminary, may contain errors, and could change substantially in the final published version. While preprints promote rapid scientific exchange, they should not be cited as established scientific fact, reported as definitive in news media, or used to guide clinical decisions without appropriate context.
:::

:::{#preprints}
:::